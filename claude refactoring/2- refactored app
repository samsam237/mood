// =====================================================
// COMPLETE REFACTORED MOOD TRACKING APP
// =====================================================

// ==================== PACKAGE.JSON ====================
{
  "name": "mood-tracker-app",
  "version": "1.0.0",
  "main": "node_modules/expo/AppEntry.js",
  "scripts": {
    "start": "expo start",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web"
  },
  "dependencies": {
    "expo": "~50.0.0",
    "react": "18.2.0",
    "react-native": "0.73.0",
    "@react-navigation/native": "^6.1.9",
    "@react-navigation/bottom-tabs": "^6.5.11",
    "@react-navigation/stack": "^6.3.20",
    "react-native-screens": "~3.29.0",
    "react-native-safe-area-context": "4.8.2",
    "@react-native-google-signin/google-signin": "^10.1.0",
    "react-native-fbsdk-next": "^12.1.2",
    "expo-secure-store": "~12.8.1",
    "react-native-pdf": "^6.7.3",
    "react-native-vector-icons": "^10.0.3",
    "react-native-gesture-handler": "~2.14.0",
    "react-native-reanimated": "~3.6.2",
    "@react-native-async-storage/async-storage": "1.21.0",
    "expo-linear-gradient": "~12.7.2",
    "react-native-modal": "^13.0.1"
  },
  "devDependencies": {
    "@babel/core": "^7.20.0",
    "@types/react": "~18.2.45",
    "typescript": "^5.1.3"
  }
}

// ==================== APP.JS ====================
import React from 'react';
import { StatusBar } from 'expo-status-bar';
import { NavigationContainer } from '@react-navigation/native';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import { createStackNavigator } from '@react-navigation/stack';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import Icon from 'react-native-vector-icons/MaterialIcons';

// Import screens
import HomeScreen from './src/screens/HomeScreen';
import MoodEntryScreen from './src/screens/MoodEntryScreen';
import AnalyticsScreen from './src/screens/AnalyticsScreen';
import ProfileScreen from './src/screens/ProfileScreen';
import AuthScreen from './src/screens/AuthScreen';
import PDFViewerScreen from './src/screens/PDFViewerScreen';

// Import contexts
import { AuthProvider, useAuth } from './src/contexts/AuthContext';
import { MoodProvider } from './src/contexts/MoodContext';
import { ThemeProvider } from './src/contexts/ThemeContext';

// Import theme
import { theme } from './src/constants/theme';

const Tab = createBottomTabNavigator();
const Stack = createStackNavigator();

// Main Tab Navigator
const MainTabNavigator = () => {
  return (
    <Tab.Navigator
      screenOptions={({ route }) => ({
        tabBarIcon: ({ focused, color, size }) => {
          let iconName;
          switch (route.name) {
            case 'Home':
              iconName = 'home';
              break;
            case 'Mood':
              iconName = 'mood';
              break;
            case 'Analytics':
              iconName = 'analytics';
              break;
            case 'Profile':
              iconName = 'person';
              break;
            default:
              iconName = 'help';
          }
          return <Icon name={iconName} size={size} color={color} />;
        },
        tabBarActiveTintColor: theme.colors.primary,
        tabBarInactiveTintColor: theme.colors.textSecondary,
        tabBarStyle: {
          backgroundColor: theme.colors.surface,
          borderTopWidth: 1,
          borderTopColor: theme.colors.border,
          paddingBottom: 8,
          paddingTop: 8,
          height: 70,
        },
        headerStyle: {
          backgroundColor: theme.colors.primary,
        },
        headerTintColor: theme.colors.white,
        headerTitleStyle: {
          fontWeight: 'bold',
        },
      })}
    >
      <Tab.Screen name="Home" component={HomeScreen} />
      <Tab.Screen name="Mood" component={MoodEntryScreen} />
      <Tab.Screen name="Analytics" component={AnalyticsScreen} />
      <Tab.Screen name="Profile" component={ProfileScreen} />
    </Tab.Navigator>
  );
};

// Main Stack Navigator
const MainStackNavigator = () => {
  return (
    <Stack.Navigator>
      <Stack.Screen 
        name="MainTabs" 
        component={MainTabNavigator} 
        options={{ headerShown: false }}
      />
      <Stack.Screen 
        name="PDFViewer" 
        component={PDFViewerScreen}
        options={{ 
          title: 'PDF Viewer',
          headerStyle: { backgroundColor: theme.colors.primary },
          headerTintColor: theme.colors.white,
        }}
      />
    </Stack.Navigator>
  );
};

// App Content Component
const AppContent = () => {
  const { user, loading } = useAuth();

  if (loading) {
    return null; // Add loading screen here
  }

  return (
    <NavigationContainer>
      {user ? <MainStackNavigator /> : <AuthScreen />}
    </NavigationContainer>
  );
};

// Main App Component
export default function App() {
  return (
    <SafeAreaProvider>
      <ThemeProvider>
        <AuthProvider>
          <MoodProvider>
            <StatusBar style="light" backgroundColor={theme.colors.primary} />
            <AppContent />
          </MoodProvider>
        </AuthProvider>
      </ThemeProvider>
    </SafeAreaProvider>
  );
}

// ==================== THEME CONSTANTS ====================
// src/constants/theme.js
export const theme = {
  colors: {
    primary: '#6366F1',
    primaryDark: '#4F46E5',
    secondary: '#8B5CF6',
    background: '#FFFFFF',
    surface: '#F8FAFC',
    card: '#FFFFFF',
    text: '#1F2937',
    textSecondary: '#6B7280',
    textLight: '#9CA3AF',
    error: '#EF4444',
    success: '#10B981',
    warning: '#F59E0B',
    info: '#3B82F6',
    white: '#FFFFFF',
    black: '#000000',
    border: '#E5E7EB',
    disabled: '#D1D5DB',
    overlay: 'rgba(0, 0, 0, 0.5)',
  },
  spacing: {
    xs: 4,
    sm: 8,
    md: 16,
    lg: 24,
    xl: 32,
    xxl: 48,
  },
  typography: {
    h1: {
      fontSize: 32,
      fontWeight: 'bold',
      lineHeight: 40,
    },
    h2: {
      fontSize: 24,
      fontWeight: 'bold',
      lineHeight: 32,
    },
    h3: {
      fontSize: 20,
      fontWeight: '600',
      lineHeight: 28,
    },
    body: {
      fontSize: 16,
      fontWeight: 'normal',
      lineHeight: 24,
    },
    bodySmall: {
      fontSize: 14,
      fontWeight: 'normal',
      lineHeight: 20,
    },
    caption: {
      fontSize: 12,
      fontWeight: 'normal',
      lineHeight: 16,
    },
  },
  borderRadius: {
    sm: 4,
    md: 8,
    lg: 16,
    xl: 24,
    round: 999,
  },
  shadows: {
    small: {
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 1 },
      shadowOpacity: 0.1,
      shadowRadius: 2,
      elevation: 2,
    },
    medium: {
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 2 },
      shadowOpacity: 0.15,
      shadowRadius: 4,
      elevation: 4,
    },
    large: {
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 4 },
      shadowOpacity: 0.2,
      shadowRadius: 8,
      elevation: 8,
    },
  },
};

// ==================== AUTH CONTEXT ====================
// src/contexts/AuthContext.js
import React, { createContext, useContext, useState, useEffect } from 'react';
import { GoogleSignin } from '@react-native-google-signin/google-signin';
import { LoginManager, AccessToken } from 'react-native-fbsdk-next';
import * as SecureStore from 'expo-secure-store';
import { authService } from '../services/authService';

const AuthContext = createContext();

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    initializeAuth();
  }, []);

  const initializeAuth = async () => {
    try {
      // Configure Google Sign-In
      GoogleSignin.configure({
        webClientId: 'YOUR_WEB_CLIENT_ID', // Replace with your actual web client ID
        iosClientId: 'YOUR_IOS_CLIENT_ID', // Replace with your actual iOS client ID
        offlineAccess: true,
        hostedDomain: '',
        forceCodeForRefreshToken: true,
      });

      // Check for existing authentication
      const savedUser = await SecureStore.getItemAsync('user');
      if (savedUser) {
        setUser(JSON.parse(savedUser));
      }
    } catch (error) {
      console.error('Auth initialization error:', error);
    } finally {
      setLoading(false);
    }
  };

  const signInWithGoogle = async () => {
    try {
      await GoogleSignin.hasPlayServices();
      const userInfo = await GoogleSignin.signIn();
      
      await SecureStore.setItemAsync('googleToken', userInfo.idToken);
      await SecureStore.setItemAsync('user', JSON.stringify(userInfo.user));
      
      setUser(userInfo.user);
      return { success: true };
    } catch (error) {
      console.error('Google Sign-In Error:', error);
      return { success: false, error: error.message };
    }
  };

  const signInWithFacebook = async () => {
    try {
      const result = await LoginManager.logInWithPermissions(['public_profile', 'email']);
      
      if (result.isCancelled) {
        return { success: false, error: 'Login cancelled' };
      }

      const data = await AccessToken.getCurrentAccessToken();
      if (data) {
        const { accessToken } = data;
        await SecureStore.setItemAsync('facebookToken', accessToken);
        
        // Fetch user info from Facebook Graph API
        const userInfo = await authService.getFacebookUserInfo(accessToken);
        await SecureStore.setItemAsync('user', JSON.stringify(userInfo));
        
        setUser(userInfo);
        return { success: true };
      }
    } catch (error) {
      console.error('Facebook Login Error:', error);
      return { success: false, error: error.message };
    }
  };

  const signOut = async () => {
    try {
      await GoogleSignin.signOut();
      await LoginManager.logOut();
      await SecureStore.deleteItemAsync('user');
      await SecureStore.deleteItemAsync('googleToken');
      await SecureStore.deleteItemAsync('facebookToken');
      setUser(null);
    } catch (error) {
      console.error('Sign out error:', error);
    }
  };

  const value = {
    user,
    loading,
    signInWithGoogle,
    signInWithFacebook,
    signOut,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

// ==================== MOOD CONTEXT ====================
// src/contexts/MoodContext.js
import React, { createContext, useContext, useState, useEffect } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { moodService } from '../services/moodService';

const MoodContext = createContext();

export const useMood = () => {
  const context = useContext(MoodContext);
  if (!context) {
    throw new Error('useMood must be used within a MoodProvider');
  }
  return context;
};

export const MoodProvider = ({ children }) => {
  const [moods, setMoods] = useState([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    loadMoods();
  }, []);

  const loadMoods = async () => {
    try {
      setLoading(true);
      const savedMoods = await AsyncStorage.getItem('moods');
      if (savedMoods) {
        setMoods(JSON.parse(savedMoods));
      }
    } catch (error) {
      console.error('Error loading moods:', error);
    } finally {
      setLoading(false);
    }
  };

  const saveMood = async (moodData) => {
    try {
      const newMood = {
        id: Date.now().toString(),
        ...moodData,
        timestamp: new Date().toISOString(),
      };
      
      const updatedMoods = [newMood, ...moods];
      setMoods(updatedMoods);
      await AsyncStorage.setItem('moods', JSON.stringify(updatedMoods));
      
      return { success: true };
    } catch (error) {
      console.error('Error saving mood:', error);
      return { success: false, error: error.message };
    }
  };

  const getMoodAnalytics = () => {
    return moodService.generateAnalytics(moods);
  };

  const value = {
    moods,
    loading,
    saveMood,
    getMoodAnalytics,
  };

  return <MoodContext.Provider value={value}>{children}</MoodContext.Provider>;
};

// ==================== THEME CONTEXT ====================
// src/contexts/ThemeContext.js
import React, { createContext, useContext, useState } from 'react';
import { theme as defaultTheme } from '../constants/theme';

const ThemeContext = createContext();

export const useTheme = () => {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  return context;
};

export const ThemeProvider = ({ children }) => {
  const [isDarkMode, setIsDarkMode] = useState(false);

  const toggleTheme = () => {
    setIsDarkMode(!isDarkMode);
  };

  const theme = {
    ...defaultTheme,
    isDark: isDarkMode,
  };

  const value = {
    theme,
    isDarkMode,
    toggleTheme,
  };

  return <ThemeContext.Provider value={value}>{children}</ThemeContext.Provider>;
};

// ==================== AUTH SERVICE ====================
// src/services/authService.js
export const authService = {
  async getFacebookUserInfo(accessToken) {
    try {
      const response = await fetch(
        `https://graph.facebook.com/me?fields=id,name,email,picture&access_token=${accessToken}`
      );
      const userInfo = await response.json();
      return {
        id: userInfo.id,
        name: userInfo.name,
        email: userInfo.email,
        photo: userInfo.picture?.data?.url,
      };
    } catch (error) {
      console.error('Error fetching Facebook user info:', error);
      throw error;
    }
  },

  async refreshGoogleToken() {
    try {
      const tokens = await GoogleSignin.getTokens();
      return tokens;
    } catch (error) {
      console.error('Error refreshing Google token:', error);
      throw error;
    }
  },
};

// ==================== MOOD SERVICE ====================
// src/services/moodService.js
export const moodService = {
  generateAnalytics(moods) {
    if (!moods || moods.length === 0) {
      return {
        averageMood: 0,
        moodTrend: [],
        moodDistribution: {},
        weeklyAverage: 0,
      };
    }

    // Calculate average mood
    const averageMood = moods.reduce((sum, mood) => sum + mood.value, 0) / moods.length;

    // Generate mood trend for last 30 days
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
    
    const recentMoods = moods.filter(
      mood => new Date(mood.timestamp) >= thirtyDaysAgo
    );

    const moodTrend = recentMoods.map(mood => ({
      date: new Date(mood.timestamp).toLocaleDateString(),
      value: mood.value,
    }));

    // Calculate mood distribution
    const moodDistribution = moods.reduce((acc, mood) => {
      acc[mood.label] = (acc[mood.label] || 0) + 1;
      return acc;
    }, {});

    // Calculate weekly average
    const weekAgo = new Date();
    weekAgo.setDate(weekAgo.getDate() - 7);
    const weeklyMoods = moods.filter(
      mood => new Date(mood.timestamp) >= weekAgo
    );
    const weeklyAverage = weeklyMoods.length > 0 
      ? weeklyMoods.reduce((sum, mood) => sum + mood.value, 0) / weeklyMoods.length
      : 0;

    return {
      averageMood,
      moodTrend,
      moodDistribution,
      weeklyAverage,
    };
  },
};

// ==================== PDF SERVICE ====================
// src/services/pdfService.js
export const pdfService = {
  async validatePDFUrl(url) {
    try {
      const response = await fetch(url, { method: 'HEAD' });
      return response.ok && response.headers.get('content-type')?.includes('pdf');
    } catch (error) {
      return false;
    }
  },

  async downloadPDF(url, filename) {
    try {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error('Failed to download PDF');
      }
      // Handle PDF download logic here
      return { success: true, localPath: filename };
    } catch (error) {
      console.error('PDF Download Error:', error);
      return { success: false, error: error.message };
    }
  },
};

// ==================== COMMON COMPONENTS ====================
// src/components/common/Button.js
import React from 'react';
import { TouchableOpacity, Text, StyleSheet, ActivityIndicator } from 'react-native';
import { theme } from '../../constants/theme';

const Button = ({ 
  title, 
  onPress, 
  variant = 'primary', 
  size = 'medium',
  disabled = false,
  loading = false,
  style,
  ...props 
}) => {
  const buttonStyle = [
    styles.button,
    styles[variant],
    styles[size],
    disabled && styles.disabled,
    style,
  ];

  const textStyle = [
    styles.buttonText,
    styles[`${variant}Text`],
    styles[`${size}Text`],
  ];

  return (
    <TouchableOpacity
      style={buttonStyle}
      onPress={onPress}
      disabled={disabled || loading}
      accessibilityRole="button"
      accessibilityLabel={title}
      accessibilityState={{ disabled: disabled || loading }}
      {...props}
    >
      {loading ? (
        <ActivityIndicator color={variant === 'primary' ? theme.colors.white : theme.colors.primary} />
      ) : (
        <Text style={textStyle}>{title}</Text>
      )}
    </TouchableOpacity>
  );
};

const styles = StyleSheet.create({
  button: {
    justifyContent: 'center',
    alignItems: 'center',
    borderRadius: theme.borderRadius.md,
    ...theme.shadows.small,
  },
  primary: {
    backgroundColor: theme.colors.primary,
  },
  secondary: {
    backgroundColor: theme.colors.secondary,
  },
  outline: {
    backgroundColor: 'transparent',
    borderWidth: 2,
    borderColor: theme.colors.primary,
  },
  text: {
    backgroundColor: 'transparent',
  },
  small: {
    paddingVertical: theme.spacing.sm,
    paddingHorizontal: theme.spacing.md,
    minHeight: 36,
  },
  medium: {
    paddingVertical: theme.spacing.md,
    paddingHorizontal: theme.spacing.lg,
    minHeight: 48,
  },
  large: {
    paddingVertical: theme.spacing.lg,
    paddingHorizontal: theme.spacing.xl,
    minHeight: 56,
  },
  disabled: {
    backgroundColor: theme.colors.disabled,
    opacity: 0.6,
  },
  buttonText: {
    fontWeight: '600',
    textAlign: 'center',
  },
  primaryText: {
    color: theme.colors.white,
  },
  secondaryText: {
    color: theme.colors.white,
  },
  outlineText: {
    color: theme.colors.primary,
  },
  textText: {
    color: theme.colors.primary,
  },
  smallText: {
    fontSize: 14,
  },
  mediumText: {
    fontSize: 16,
  },
  largeText: {
    fontSize: 18,
  },
});

export default Button;

// ==================== CARD COMPONENT ====================
// src/components/common/Card.js
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { theme } from '../../constants/theme';

const Card = ({ children, style, ...props }) => {
  return (
    <View style={[styles.card, style]} {...props}>
      {children}
    </View>
  );
};

const styles = StyleSheet.create({
  card: {
    backgroundColor: theme.colors.card,
    borderRadius: theme.borderRadius.lg,
    padding: theme.spacing.md,
    margin: theme.spacing.sm,
    ...theme.shadows.medium,
  },
});

export default Card;